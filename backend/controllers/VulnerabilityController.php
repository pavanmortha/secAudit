<?php
class VulnerabilityController {
    private $db;

    public function __construct($db) {
        $this->db = $db;
    }

    public function getAll() {
        try {
            $query = "SELECT v.*, a.name as asset_name, au.title as audit_title, u.name as assigned_to_name
                      FROM vulnerabilities v
                      LEFT JOIN assets a ON v.asset_id = a.id
                      LEFT JOIN audits au ON v.audit_id = au.id
                      LEFT JOIN users u ON v.assigned_to = u.id
                      ORDER BY v.discovered_date DESC";
            
            $stmt = $this->db->prepare($query);
            $stmt->execute();
            $vulnerabilities = $stmt->fetchAll(PDO::FETCH_ASSOC);

            // Format data for frontend
            $vulnerabilities = array_map(function($vuln) {
                return [
                    'id' => $vuln['id'],
                    'auditId' => $vuln['audit_id'],
                    'assetId' => $vuln['asset_id'],
                    'title' => $vuln['title'],
                    'description' => $vuln['description'],
                    'severity' => $vuln['severity'],
                    'cvssScore' => (float)$vuln['cvss_score'],
                    'epssScore' => $vuln['epss_score'] ? (float)$vuln['epss_score'] : null,
                    'cveId' => $vuln['cve_id'],
                    'category' => $vuln['category'],
                    'status' => $vuln['status'],
                    'assignedTo' => $vuln['assigned_to_name'],
                    'dueDate' => $vuln['due_date'],
                    'rootCause' => $vuln['root_cause'],
                    'remediation' => $vuln['remediation'],
                    'evidence' => $vuln['evidence'] ? json_decode($vuln['evidence'], true) : null,
                    'discoveredDate' => $vuln['discovered_date'],
                    'resolvedDate' => $vuln['resolved_date'],
                    'assetName' => $vuln['asset_name'],
                    'auditTitle' => $vuln['audit_title']
                ];
            }, $vulnerabilities);

            http_response_code(200);
            echo json_encode($vulnerabilities);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to fetch vulnerabilities: ' . $e->getMessage()]);
        }
    }

    public function getById($id) {
        try {
            $query = "SELECT v.*, a.name as asset_name, au.title as audit_title, u.name as assigned_to_name
                      FROM vulnerabilities v
                      LEFT JOIN assets a ON v.asset_id = a.id
                      LEFT JOIN audits au ON v.audit_id = au.id
                      LEFT JOIN users u ON v.assigned_to = u.id
                      WHERE v.id = :id";
            
            $stmt = $this->db->prepare($query);
            $stmt->bindParam(':id', $id);
            $stmt->execute();

            if ($stmt->rowCount() > 0) {
                $vuln = $stmt->fetch(PDO::FETCH_ASSOC);
                
                $formatted_vuln = [
                    'id' => $vuln['id'],
                    'auditId' => $vuln['audit_id'],
                    'assetId' => $vuln['asset_id'],
                    'title' => $vuln['title'],
                    'description' => $vuln['description'],
                    'severity' => $vuln['severity'],
                    'cvssScore' => (float)$vuln['cvss_score'],
                    'epssScore' => $vuln['epss_score'] ? (float)$vuln['epss_score'] : null,
                    'cveId' => $vuln['cve_id'],
                    'category' => $vuln['category'],
                    'status' => $vuln['status'],
                    'assignedTo' => $vuln['assigned_to_name'],
                    'dueDate' => $vuln['due_date'],
                    'rootCause' => $vuln['root_cause'],
                    'remediation' => $vuln['remediation'],
                    'evidence' => $vuln['evidence'] ? json_decode($vuln['evidence'], true) : null,
                    'discoveredDate' => $vuln['discovered_date'],
                    'resolvedDate' => $vuln['resolved_date'],
                    'assetName' => $vuln['asset_name'],
                    'auditTitle' => $vuln['audit_title']
                ];
                
                http_response_code(200);
                echo json_encode($formatted_vuln);
            } else {
                http_response_code(404);
                echo json_encode(['error' => 'Vulnerability not found']);
            }
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to fetch vulnerability: ' . $e->getMessage()]);
        }
    }

    public function create() {
        try {
            $data = json_decode(file_get_contents("php://input"), true);
            
            $required_fields = ['auditId', 'assetId', 'title', 'description', 'severity', 'cvssScore', 'category'];
            foreach ($required_fields as $field) {
                if (!isset($data[$field])) {
                    http_response_code(400);
                    echo json_encode(['error' => ucfirst($field) . ' is required']);
                    return;
                }
            }

            // Get assigned_to user ID if provided
            $assigned_to_id = null;
            if (isset($data['assignedTo']) && !empty($data['assignedTo'])) {
                $user_query = "SELECT id FROM users WHERE name = :name";
                $user_stmt = $this->db->prepare($user_query);
                $user_stmt->bindParam(':name', $data['assignedTo']);
                $user_stmt->execute();
                if ($user_stmt->rowCount() > 0) {
                    $assigned_to_id = $user_stmt->fetch(PDO::FETCH_ASSOC)['id'];
                }
            }

            $query = "INSERT INTO vulnerabilities (audit_id, asset_id, title, description, severity, cvss_score, epss_score, cve_id, category, status, assigned_to, due_date, root_cause, remediation, evidence) 
                      VALUES (:audit_id, :asset_id, :title, :description, :severity, :cvss_score, :epss_score, :cve_id, :category, :status, :assigned_to, :due_date, :root_cause, :remediation, :evidence)";
            
            $stmt = $this->db->prepare($query);
            $stmt->bindParam(':audit_id', $data['auditId']);
            $stmt->bindParam(':asset_id', $data['assetId']);
            $stmt->bindParam(':title', $data['title']);
            $stmt->bindParam(':description', $data['description']);
            $stmt->bindParam(':severity', $data['severity']);
            $stmt->bindParam(':cvss_score', $data['cvssScore']);
            $stmt->bindParam(':epss_score', $data['epssScore'] ?? null);
            $stmt->bindParam(':cve_id', $data['cveId'] ?? null);
            $stmt->bindParam(':category', $data['category']);
            $stmt->bindParam(':status', $data['status'] ?? 'open');
            $stmt->bindParam(':assigned_to', $assigned_to_id);
            $stmt->bindParam(':due_date', $data['dueDate'] ?? null);
            $stmt->bindParam(':root_cause', $data['rootCause'] ?? null);
            $stmt->bindParam(':remediation', $data['remediation'] ?? null);
            $stmt->bindParam(':evidence', isset($data['evidence']) ? json_encode($data['evidence']) : null);

            if ($stmt->execute()) {
                $vuln_id = $this->db->lastInsertId();
                
                // Log activity
                $this->logActivity('create', 'vulnerability', $vuln_id, 'Created new vulnerability: ' . $data['title']);
                
                $this->getById($vuln_id);
            } else {
                http_response_code(500);
                echo json_encode(['error' => 'Failed to create vulnerability']);
            }
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to create vulnerability: ' . $e->getMessage()]);
        }
    }

    public function update($id) {
        try {
            $data = json_decode(file_get_contents("php://input"), true);
            
            // Build dynamic update query
            $fields = [];
            $params = [':id' => $id];
            
            $field_mappings = [
                'title' => 'title',
                'description' => 'description',
                'severity' => 'severity',
                'cvssScore' => 'cvss_score',
                'epssScore' => 'epss_score',
                'cveId' => 'cve_id',
                'category' => 'category',
                'status' => 'status',
                'dueDate' => 'due_date',
                'rootCause' => 'root_cause',
                'remediation' => 'remediation'
            ];
            
            foreach ($field_mappings as $frontend_field => $db_field) {
                if (isset($data[$frontend_field])) {
                    $fields[] = "$db_field = :$db_field";
                    $params[":$db_field"] = $data[$frontend_field];
                }
            }

            // Handle assigned_to separately
            if (isset($data['assignedTo'])) {
                $assigned_to_id = null;
                if (!empty($data['assignedTo'])) {
                    $user_query = "SELECT id FROM users WHERE name = :name";
                    $user_stmt = $this->db->prepare($user_query);
                    $user_stmt->bindParam(':name', $data['assignedTo']);
                    $user_stmt->execute();
                    if ($user_stmt->rowCount() > 0) {
                        $assigned_to_id = $user_stmt->fetch(PDO::FETCH_ASSOC)['id'];
                    }
                }
                $fields[] = "assigned_to = :assigned_to";
                $params[":assigned_to"] = $assigned_to_id;
            }

            // Handle evidence
            if (isset($data['evidence'])) {
                $fields[] = "evidence = :evidence";
                $params[":evidence"] = json_encode($data['evidence']);
            }

            // Set resolved_date if status is being changed to resolved
            if (isset($data['status']) && $data['status'] === 'resolved') {
                $fields[] = "resolved_date = NOW()";
            }
            
            if (empty($fields)) {
                http_response_code(400);
                echo json_encode(['error' => 'No valid fields to update']);
                return;
            }
            
            $query = "UPDATE vulnerabilities SET " . implode(', ', $fields) . " WHERE id = :id";
            $stmt = $this->db->prepare($query);
            
            if ($stmt->execute($params)) {
                // Log activity
                $this->logActivity('update', 'vulnerability', $id, 'Updated vulnerability');
                
                $this->getById($id);
            } else {
                http_response_code(500);
                echo json_encode(['error' => 'Failed to update vulnerability']);
            }
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to update vulnerability: ' . $e->getMessage()]);
        }
    }

    public function delete($id) {
        try {
            // Check if vulnerability exists
            $check_query = "SELECT title FROM vulnerabilities WHERE id = :id";
            $check_stmt = $this->db->prepare($check_query);
            $check_stmt->bindParam(':id', $id);
            $check_stmt->execute();
            
            if ($check_stmt->rowCount() === 0) {
                http_response_code(404);
                echo json_encode(['error' => 'Vulnerability not found']);
                return;
            }
            
            $vuln_title = $check_stmt->fetch(PDO::FETCH_ASSOC)['title'];
            
            $query = "DELETE FROM vulnerabilities WHERE id = :id";
            $stmt = $this->db->prepare($query);
            $stmt->bindParam(':id', $id);
            
            if ($stmt->execute()) {
                // Log activity
                $this->logActivity('delete', 'vulnerability', $id, 'Deleted vulnerability: ' . $vuln_title);
                
                http_response_code(200);
                echo json_encode(['success' => true, 'message' => 'Vulnerability deleted successfully']);
            } else {
                http_response_code(500);
                echo json_encode(['error' => 'Failed to delete vulnerability']);
            }
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to delete vulnerability: ' . $e->getMessage()]);
        }
    }

    public function bulkUpdate() {
        try {
            $data = json_decode(file_get_contents("php://input"), true);
            
            if (!isset($data['updates']) || !is_array($data['updates'])) {
                http_response_code(400);
                echo json_encode(['error' => 'Updates array is required']);
                return;
            }

            $this->db->beginTransaction();
            
            foreach ($data['updates'] as $update) {
                if (!isset($update['id']) || !isset($update['data'])) {
                    continue;
                }
                
                // Use the existing update logic for each vulnerability
                $this->updateVulnerabilityById($update['id'], $update['data']);
            }
            
            $this->db->commit();
            
            http_response_code(200);
            echo json_encode(['success' => true, 'message' => 'Bulk update completed successfully']);
        } catch (Exception $e) {
            $this->db->rollBack();
            http_response_code(500);
            echo json_encode(['error' => 'Failed to perform bulk update: ' . $e->getMessage()]);
        }
    }

    private function updateVulnerabilityById($id, $data) {
        // Similar to update() method but without HTTP responses
        $fields = [];
        $params = [':id' => $id];
        
        $field_mappings = [
            'title' => 'title',
            'description' => 'description',
            'severity' => 'severity',
            'cvssScore' => 'cvss_score',
            'epssScore' => 'epss_score',
            'cveId' => 'cve_id',
            'category' => 'category',
            'status' => 'status',
            'dueDate' => 'due_date',
            'rootCause' => 'root_cause',
            'remediation' => 'remediation'
        ];
        
        foreach ($field_mappings as $frontend_field => $db_field) {
            if (isset($data[$frontend_field])) {
                $fields[] = "$db_field = :$db_field";
                $params[":$db_field"] = $data[$frontend_field];
            }
        }

        if (isset($data['status']) && $data['status'] === 'resolved') {
            $fields[] = "resolved_date = NOW()";
        }
        
        if (!empty($fields)) {
            $query = "UPDATE vulnerabilities SET " . implode(', ', $fields) . " WHERE id = :id";
            $stmt = $this->db->prepare($query);
            $stmt->execute($params);
        }
    }

    private function logActivity($action, $entity_type, $entity_id, $details) {
        try {
            $query = "INSERT INTO activity_logs (action, entity_type, entity_id, details, ip_address, user_agent) 
                      VALUES (:action, :entity_type, :entity_id, :details, :ip_address, :user_agent)";
            
            $stmt = $this->db->prepare($query);
            $stmt->bindParam(':action', $action);
            $stmt->bindParam(':entity_type', $entity_type);
            $stmt->bindParam(':entity_id', $entity_id);
            $stmt->bindParam(':details', $details);
            $stmt->bindParam(':ip_address', $_SERVER['REMOTE_ADDR'] ?? null);
            $stmt->bindParam(':user_agent', $_SERVER['HTTP_USER_AGENT'] ?? null);
            $stmt->execute();
        } catch (Exception $e) {
            error_log("Failed to log activity: " . $e->getMessage());
        }
    }
}